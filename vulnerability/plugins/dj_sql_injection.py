from analyzer.plugin_loader import call_with
from vulnerability.vulnerability import Vulnerability, VulnerabilityType, VulnerabilityLevel
from re import finditer
from itertools import chain

djsqli = VulnerabilityType("Possible SQL Injection scenario. A Django function for writing SQL\n    "
                           "statements by hand is used and the query string parameters are quoted.\n    "
                           "This bypasses the built in protection against SQL Injection.\n    "
                           "More Information:\n    "
                           "https://docs.djangoproject.com/en/3.0/ref/models/"
                           "expressions/#django.db.models.expressions.RawSQL",
                           "Remove the quotation marks from the string parameter.",
                           VulnerabilityLevel.high)


def check_sql_str_for_quotes(sql_str):
    matches = chain(finditer("%s", sql_str), finditer("%\\([a-zA-Z0-9_]*\\)s", sql_str))
    for match in matches:
        try:
            if sql_str[match.start() - 1] == "'" and sql_str[match.end()] == "'" or \
                    sql_str[match.start() - 1] == '"' and sql_str[match.end()] == '"':
                return True
        except IndexError:
            continue  # unquoted "%s" at the end or beginning of sql_str
    return False


@call_with("Call")
def check_call_for_djsqli(self, node):
    """
    Example: RawSQL("select col from table where id = '%s'", id)
    """
    func_names = ["raw", "execute", "RawSQL"]
    if (hasattr(node.func, 'id') and node.func.id in func_names) or \
            (hasattr(node.func, 'attr') and node.func.attr in func_names):
        sql_str = node.args[0].value
        if check_sql_str_for_quotes(sql_str):
            self.vulnerabilities.add(Vulnerability(file=self.file, lineno=node.lineno, vuln_type=djsqli))
