from bs4 import BeautifulSoup

from analyzer.plugin_loader import call_with
from vulnerability.vulnerability import Vulnerability, VulnerabilityType, VulnerabilityLevel
import ast


sqlstrformat = VulnerabilityType("Possible SQL Injection scenario. A string formatting method is used on a "
                                 "string starting with one of the following SQL commands:\n    'INSERT INTO', "
                                 "'DELETE FROM', 'ALTER TABLE', 'DROP DATABASE', 'CREATE DATABASE' or containing '"
                                 "... SELECT ... FROM ...' or '... UPDATE ... SET ...'.\n    More Information: "
                                 "https://realpython.com/prevent-python-sql-injection/",
                                 "Make sure to sanitize input by escaping and input validation.",
                                 VulnerabilityLevel.high)


xssstrformat = VulnerabilityType("Possible Cross-Site Request / HTML Injection scenario. A string formatting method or "
                                 "string concatenation is used on a string containing HTML. More Information:\n    "
                                 "https://docs.djangoproject.com/en/3.1/ref/utils/#django.utils.html.format_html",
                                 "Use django.utils.html.format_html() for formatting HTML strings. If you can't use "
                                 "Django, make sure to sanitize input by escaping and input validation.",
                                 VulnerabilityLevel.moderate)


def check_for_sqli(analyzer, format_str, node):
    sqli_found = False
    format_str = format_str.upper()
    sql_strings = ["INSERT INTO", "DELETE FROM", "CREATE TABLE", "ALTER TABLE", "DROP TABLE", "TRUNCATE TABLE",
                   "DROP DATABASE", "CREATE DATABASE", "CREATE TRIGGER", "DROP TRIGGER", "CREATE VIEW", "DROP VIEW"]
    sql_tuples = [("SELECT", "FROM"), ("UPDATE", "SET")]  # These need to be in sequence
    if any(sql_str in format_str for sql_str in sql_strings):
        sqli_found = True
    for sql_tuple in sql_tuples:
        index0 = format_str.find(sql_tuple[0])
        if index0 != -1:
            if format_str.find(sql_tuple[1], index0 + len(sql_tuple[0])) != -1:
                sqli_found = True
    if sqli_found:
        analyzer.vulnerabilities.add(Vulnerability(file=analyzer.file, lineno=node.lineno, vuln_type=sqlstrformat))


def check_for_xss(format_str):
    format_str = format_str.lower()
    # try to parse the string to html to check if it is html
    if bool(BeautifulSoup(format_str, "html.parser").find()):
        return True
    else:
        return False


@call_with("JoinedStr")
def sqli_check_JoinedStr(self, node):
    """
    JoinedStr example: f"Hello {0}"
    """
    format_string = ""
    for val in node.values:
        if isinstance(val, ast.Constant):
            if isinstance(val.value, str):
                format_string += val.value
    check_for_sqli(self, format_string, node)
    check_for_xss(self, format_string, node)


@call_with("Attribute")
def sqli_check_Attribute(self, node):
    """
    example: "SELECT * FROM users WHERE id = {0}".format(id)
    """
    if node.attr == "format":
        check_for_sqli(self, node.value.value, node)
        check_for_xss(self, node.value.value, node)


@call_with("BinOp")
def sqli_check_BinOp(self, node):
    if isinstance(node.op, ast.Mod):  # Modulo operator used for string formatting like "hello %s" % x
        if isinstance(node.left, ast.Constant):  # left side is string constant
            if "%s" in node.left.value:  # %d, %f are not receptive to injection as they only accept numbers
                check_for_sqli(self, node.left.value, node)
                check_for_xss(self, node.left.value, node)

    if isinstance(node.op, ast.Add):  # Add operator for string concatenation like "hello " + x
        self.dynamic_content = False  # Flag if strings are concatenated with variables
        self.concatenated_str = ""

        def build_cat_str(binop_node):
            if isinstance(binop_node.left, ast.BinOp):  # The concatenated str is built recursively from left to right
                build_cat_str(binop_node.left)
            else:
                if isinstance(binop_node.left, ast.Constant) and isinstance(binop_node.left.value, str):
                    self.concatenated_str += binop_node.left.value
            if isinstance(binop_node.right, ast.Constant) and isinstance(binop_node.right.value, str):
                self.concatenated_str += binop_node.right.value
            if isinstance(binop_node.right, ast.Name) or isinstance(binop_node.left, ast.Name):
                self.dynamic_content = True

        build_cat_str(node)
        if self.dynamic_content and self.concatenated_str:
            check_for_sqli(self, self.concatenated_str, node)
            check_for_xss(self, self.concatenated_str, node)
        del self.dynamic_content
        del self.concatenated_str