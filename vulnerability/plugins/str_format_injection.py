from bs4 import BeautifulSoup

from analyzer.plugin_loader import call_with
from vulnerability.vulnerability import Vulnerability, VulnerabilityType, VulnerabilityLevel
import ast


sqlstrformat = VulnerabilityType("Possible SQL Injection scenario. A string formatting method is\n    "
                                 "used on a string starting with one of the following SQL commands:\n    "
                                 "'INSERT INTO', 'DELETE FROM', 'ALTER TABLE', 'DROP DATABASE',\n    "
                                 "'CREATE DATABASE' or containing '... SELECT ... FROM ...' or\n    "
                                 "'... UPDATE ... SET ...'. More Information:\n    "
                                 "https://realpython.com/prevent-python-sql-injection/",
                                 "Make sure to sanitize input by escaping and input validation.",
                                 VulnerabilityLevel.high)


xssstrformat = VulnerabilityType("Possible Cross-Site Request / HTML Injection scenario. A string\n    "
                                 "formatting method or string concatenation is used on a string\n    "
                                 "containing HTML. More Information:\n    "
                                 "https://docs.djangoproject.com/en/3.1/ref/utils/#django.utils.html.format_html",
                                 "Use django.utils.html.format_html() for formatting HTML strings.\n    "
                                 "If you can't use Django, make sure to sanitize input by escaping\n    "
                                 "and input validation.",
                                 VulnerabilityLevel.moderate)


def check_for_sqli(analyzer, format_str, node):
    sqli_found = False
    format_str = format_str.upper()
    # Check for these strings in the format string. If one is found, the format str very probably contains SQL
    sql_strings = ["INSERT INTO", "DELETE FROM", "CREATE TABLE", "ALTER TABLE", "DROP TABLE", "TRUNCATE TABLE",
                   "DROP DATABASE", "CREATE DATABASE", "CREATE TRIGGER", "DROP TRIGGER", "CREATE VIEW", "DROP VIEW"]
    sql_tuples = [("SELECT", "FROM"), ("UPDATE", "SET")]  # These need to be in sequence
    if any(sql_str in format_str for sql_str in sql_strings):
        sqli_found = True
    for sql_tuple in sql_tuples:
        index0 = format_str.find(sql_tuple[0])
        if index0 != -1:
            if format_str.find(sql_tuple[1], index0 + len(sql_tuple[0])) != -1:
                sqli_found = True
    if sqli_found:
        analyzer.vulnerabilities.add(Vulnerability(file=analyzer.file, lineno=node.lineno, vuln_type=sqlstrformat))


def check_for_xss(analyzer, format_str, node):
    format_str = format_str.lower()
    # try to parse the string to html to check if it is html
    if bool(BeautifulSoup(format_str, "html.parser").find()):
        analyzer.vulnerabilities.add(Vulnerability(file=analyzer.file,
                                                   lineno=node.lineno,
                                                   vuln_type=xssstrformat))


@call_with("JoinedStr")
def stri_check_JoinedStr(self, node):
    """
    JoinedStr example: f"Hello {x}"
    """
    format_string = ""
    for val in node.values:
        if isinstance(val, ast.Constant):
            if isinstance(val.value, str):
                format_string += val.value
    check_for_sqli(self, format_string, node)
    check_for_xss(self, format_string, node)


@call_with("Attribute")
def stri_check_Attribute(self, node):
    """
    Example: "Hello {0}".format(x)
    """
    if node.attr == "format":
        check_for_sqli(self, node.value.value, node)
        check_for_xss(self, node.value.value, node)


@call_with("BinOp")
def stri_check_BinOp(self, node):
    """
    Example for string formatting: "Hello %s" % x
    Example for string concatenation: "Hello %s" % x
    """
    if isinstance(node.op, ast.Mod):  # Modulo operator used for string formatting
        if isinstance(node.left, ast.Constant):  # left side is string constant
            if "%s" in node.left.value:  # %d, %f are not receptive to injection as they only accept numbers
                check_for_sqli(self, node.left.value, node)
                check_for_xss(self, node.left.value, node)

    if isinstance(node.op, ast.Add):  # Add operator for string concatenation
        self.dynamic_content = False  # Flag if strings are concatenated with variables
        self.concatenated_str = ""

        def build_cat_str(binop_node):
            if isinstance(binop_node.left, ast.BinOp):  # The concatenated str is built recursively from left to right
                build_cat_str(binop_node.left)
            else:
                if isinstance(binop_node.left, ast.Constant) and isinstance(binop_node.left.value, str):
                    self.concatenated_str += binop_node.left.value
            if isinstance(binop_node.right, ast.Constant) and isinstance(binop_node.right.value, str):
                self.concatenated_str += binop_node.right.value
            if isinstance(binop_node.right, ast.Name) or isinstance(binop_node.left, ast.Name):
                self.dynamic_content = True

        build_cat_str(node)
        if self.dynamic_content and self.concatenated_str:
            check_for_sqli(self, self.concatenated_str, node)
            check_for_xss(self, self.concatenated_str, node)
        del self.dynamic_content
        del self.concatenated_str
